---
jupytext:
  text_representation:
    extension: .md
    format_name: myst
    format_version: 0.13
    jupytext_version: 1.13.6
kernelspec:
  display_name: Python 3
  language: python
  name: python3
---


# Collections

(examples-collections-construction)=

## Collection construction

The `Collection` class is a versatile way of grouping and manipulating Magpylib  objects. When objects are added to a Collection they are added by reference (**not copied**) to the attributes `children` (list of all objects), `sources` (list of the sources) and `sensors` (list of the sensors). These attributes are ordered lists. New additions are always added at the end.

```{code-cell} ipython3
import magpylib as magpy

loop = magpy.current.Loop()
sens = magpy.Sensor()

coll = magpy.Collection(loop, sens)

print(f"children: {coll.children}")
print(f"sources:  {coll.sources}")
print(f"sensors:  {coll.sensors}")
```

To manipulate existing collections, one can use the `add` and `remove` methods:

```{code-cell} ipython3
coll.add(magpy.magnet.Cuboid())
coll.remove(sens)

print(f"children: {coll.children}")
print(f"sources:  {coll.sources}")
print(f"sensors:  {coll.sensors}")
```

The operators `+` and `-` provide a similar functionality,

```{code-cell} ipython3
coll = coll - loop
coll = coll + magpy.magnet.Cylinder()

print(f"children: {coll.children}")
print(f"sources:  {coll.sources}")
print(f"sensors:  {coll.sensors}")
```

However, it must be noted that using `+` and `-` results in copies of the Collection, while `add` and `remove` does not.

The `+` operator is defined for all Magpylib objects. Adding objects returns a collection.

```{code-cell} ipython3
what_is_it = loop + sens
print(what_is_it)
```

Collections have `__getitem__` through the attribute `children` defined. This allows using collections as iterators,

```{code-cell} ipython3
for child in coll:
    print(child)
```

and makes it possible to directly reference to a child object:

```{code-cell} ipython3
print(coll[0])
```

Finally, it is worth mentioning that collections do not allow duplicate sources. They will automatically be removed. However, sources can be part of multiple collections.

(examples-collections-compound)=

## Collections as compounds

While collections work well as groups, they follow the *compound philisophy*. The idea is that a compound object, made up of multiple individual sources and sensors can be treated like single object itself. 

For this purpose, the collection has itself `position` and `orientation` attributes that span a local coordinate reference frame. Whenever a child is added to the collection it has a `position` and `orientation` in the local frame. All operations acting on the collection will then only move the local frame around, and not change child positions within it. Operations acting directly on the child itself will move the child also in the local frame.

```{code-cell} ipython3
import numpy as np
import magpylib as magpy

# construct two coil compounds
coil1 = magpy.Collection()
for z in np.linspace(-.5, .5, 5):
    winding = magpy.current.Loop(current=1, diameter=20, position=(0,0,z))
    coil1.add(winding)
coil1.position = (0,0,-5)
coil2 = coil1.copy(position = (0,0,5))

# construct a helmholz compound
helmholtz = coil1 + coil2

# move the helmholz compound
helmholtz.position = np.linspace((0,0,0), (20,0,0), 30)
helmholtz.rotate_from_angax(np.linspace(0,360,30), 'x', start=0)

# move the coils
coil1.move(np.linspace((0,0,0), (0,0,-5), 30))
coil2.move(np.linspace((0,0,0), (0,0, 5), 30))
#for coil in [coil1, coil2]:
#    coil.rotate_from_angax(np.linspace(0,360,30), 'y', start=30)
# UNCOMMENT THIS WHEN #488 IS RESOLVED !!!!!!!!!!!!!!!!!!!!!!!!!!!!!

# move the windings
for coil in [coil1, coil2]:
    for i,w in enumerate(coil):
        w.move(np.linspace((0,0,0), (0,0,i-2), 20))

helmholtz.show(backend='plotly', animation=4, style_path_show=False)
```

The compound philisophy is also followed when computing the magnetic field. Collections behave like single source inputs in the functions `getB` and `getH`. The field that is returned is simply the the sum of the fields of all child sources. In the following example the field generated by the helmholtz compound above, and by the individual coils is computed at position $(0,0,0)$:

```{code-cell} ipython3
helmholtz.reset_path()

print(magpy.getB(helmholtz, (0,0,0)))
print(magpy.getB(coil1, (0,0,0)))
print(magpy.getB(coil2, (0,0,0)))
```

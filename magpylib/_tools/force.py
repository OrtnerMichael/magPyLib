import numpy as np
from scipy.spatial.transform import Rotation as R
import magpylib as magpy


def getFT(sources, observers, mass_center, eps=1e-6):
    """
    Compute force and torque acting on a center of mass through a set of
    observer magnets generated by a magnetic field from a set of source objects.

    Computation based on magnetic moment approximation (=point approx) for
    each observer magnet

    F = grad(m.B)
    T = m x B  +  F x r

    Parameters
    ----------
    sources: list of objects with .getB() method
        Generators of the magnetic field.
    observer: list or Collection of Magpylib Cuboid objects
        Force and Torque are computed through interaction between field
        and observers
    mass_center: array_like, shape (3,), unit [mm]
        Observer force and torque are computed with respect to center of mass
    eps: float, unit [mm]
        Discretization length used for central difference approximation for
        computation of the gradient.

    Returns
    -------
    FT: ndarray (F,T), shape (2,3)
        Force vector F in units of [N] and Torque vector T in units of [Nm]
    """

    # load observer properties
    pos = np.array([obs.position for obs in observers])
    rot = R.from_quat([obs.orientation.as_quat() for obs in observers])
    dim = np.array([obs.dimension for obs in observers])
    mag = np.array([obs.magnetization for obs in observers])

    vol = np.prod(dim, axis=1)       # observer volume, unit [mm^3]
    mag_glob = rot.apply(mag)        # observer magnetizations in global CS, unit [mT]
    mom_glob = (mag_glob.T * vol).T  # observer moments in global CS, unit = [T*m^3] * 1e-12 / mu0

    # compute field around observer position
    eps = 1e-6
    d_pos = np.array([(0,0,0), (eps,0,0), (-eps,0,0), (0,eps,0), (0,-eps,0), (0,0,eps), (0,0,-eps)])
    poso = np.array([d_pos + pp for pp in pos])
    B = magpy.getB(sources, poso, sumup=True, squeeze=False)  # unit = [T] * 1e-3
    B = B[0,0]

    # central difference representation of d/dr_i B_j
    gradB =(B[:,1::2]-B[:,2::2]) / (2*eps)          # unit = [mT/mm]

    # observer positions in center-of-mass (com) system
    pos_com = pos - mass_center
    pos_com_norm = np.linalg.norm(pos_com, axis=1)

    # compute forces F and Torques T
    gradB = np.swapaxes(gradB, 0, 1)
    Fi = np.sum(mom_glob * gradB, axis=2).T            # unit = [N] * 1e-5/(4*np.pi)
    Ti = np.cross(B[:,0], mom_glob, axisa=1)           # unit = [N*m] * 1e-8 / (4*np.pi)

    # if com != observer position, F adds a Torque of T = F x r
    mask = (pos_com_norm > 1e-14)
    if np.any(mask):
        Fi_s = Fi[mask]
        pos_com_s = pos_com[mask]                                # obs position relative to COM
        pos_com_s_unit = (pos_com_s.T / pos_com_norm[mask]).T    #    unit vector thereof
        Fi_s_project = np.sum(Fi_s * pos_com_s_unit, axis=1)     # part of F pointing in COM direct
        Fi_s_perp = Fi_s - (pos_com_s_unit.T * Fi_s_project).T   # perpendicular force vector
        Ti_s = np.cross(pos_com_s, Fi_s_perp)                    # resulting Torques

        Ti[mask] += Ti_s

    F = np.sum(Fi, axis=0) * 1e-5 / (4*np.pi) # unit [N]
    T = np.sum(Ti, axis=0) * 1e-8 / (4*np.pi) # unit [N*m]

    return np.array((F,T))

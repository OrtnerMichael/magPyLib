import numpy as np
from scipy.spatial.transform import Rotation as R
from magpylib._lib.fields.field_wrap_BH_level1 import getBH_level1
from magpylib._lib.exceptions import MagpylibBadUserInput


def getBHv_level2(**kwargs: dict) -> np.ndarray:
    """ Direct access to vectorized computation

    Parameters
    ----------
    kwargs: dict that describes the computation.

    Returns
    -------
    field: ndarray, shape (N,3), field at obs_pos in [mT] or [kA/m]

    Info
    ----
    - check inputs

    - secures input types (list/tuple -> ndarray)
    - test if mandatory inputs are there
    - sets default input variables (e.g. pos, rot) if missing
    - tiles 1D inputs vectors to correct dimension
    """

    # generate dict of secured inputs for auto-tiling ---------------
    tile_params = {}

    # mandatory general inputs ------------------
    try:
        src_type = kwargs['src_type']
        poso = np.array(kwargs['pos_obs'], dtype=float)
    except KeyError as kerr:
        msg = f'Missing input keys: {str(kerr)}'
        raise MagpylibBadUserInput(msg) from kerr
    tile_params['pos_obs'] = poso           # <-- tile

    # optional general inputs -------------------
    pos = np.array(kwargs.get('pos', (0,0,0)), dtype=float)
    tile_params['pos'] = pos                # <-- tile

    rot = kwargs.get('rot', R.from_quat((0,0,0,1)))
    tile_params['rot'] = rot.as_quat()      # <-- tile

    # mandatory class specific inputs -----------
    if src_type == 'Box':
        try:
            mag = np.array(kwargs['mag'],dtype=float)
            dim = np.array(kwargs['dim'],dtype=float)
        except KeyError as kerr:
            msg = f'Missing input keys: {str(kerr)}'
            raise MagpylibBadUserInput(msg) from kerr
        tile_params['mag'] = mag            # <-- tile
        tile_params['dim'] = dim            # <-- tile
    elif src_type == 'Cylinder':
        try:
            mag = np.array(kwargs['mag'],dtype=float)
            dim = np.array(kwargs['dim'],dtype=float)
        except KeyError as kerr:
            msg = f'Missing input keys: {str(kerr)}'
            raise MagpylibBadUserInput(msg) from kerr
        tile_params['mag'] = mag            # <-- tile
        tile_params['dim'] = dim            # <-- tile
        niter = kwargs.get('niter', 50)     # set niter
        kwargs['niter'] = niter

    # auto tile 1D parameters ---------------------------------------

    # evaluation vector length
    ns = [len(val) for val in tile_params.values() if val.ndim == 2]
    if len(set(ns)) > 1:
        msg = f'bad array input lengths: {str(set(ns))}'
        raise MagpylibBadUserInput(msg)
    n = max(ns, default=1)

    # tile 1D inputs and replace original values in kwargs
    for key,val in tile_params.items():
        if val.ndim == 1:
            kwargs[key] = np.tile(val,(n,1))
        else:
            kwargs[key] = val
    # change rot to Rotation object
    kwargs['rot'] = R.from_quat(kwargs['rot'])

    # compute and return B
    B = getBH_level1(**kwargs)

    if n==1: # remove highest level when n=1
        return B[0]
    return B


def getBv(**kwargs):
    """ B-Field computation from dictionary of vectors.

    This function avoids the magpylib interface and gives direct access to the field
        implementations. It is the fastet way to compute fields with magpylib.

    Shape (3,) inputs will automatically be tiled to shape (N,3) to fit with other
        inputs.

    Parameters
    ----------
    src_type: string
        Source type of computation. Must be either 'Box', 'Cylinder', ___

    pos: array_like, shape (3,) or (N,3), default=(0,0,0)
        Source positions in units of [mm].

    rot: scipy Rotation object, default=unit rotation
        Source rotations relative to the init_state.

    pos_obs: array_like, shape (3,) or (N,3)
        Observer positions in units of [mm]

    Homogeneous magnets Parameters
    ------------------------------
    mag: array_like, shape (3,)
        Homogeneous magnet magnetization vector (remanence field) in units of [mT].

    dim: array_like, shape is src_type dependent
        Magnet dimension input

    Specific Parameters:
    --------------------
    niter: int, default=config.ITER_CYLINDER=50
        Number of iterations for diametral magnetization computation using
        Simpsons approximation.

    Returns
    -------
    B-field: ndarray, shape (N,3)
        B-field generated by source at pos_obs in units of mT.
    """
    return getBHv_level2(bh=True, **kwargs)


def getHv(**kwargs):
    """ H-Field computation from dictionary of vectors.

    This function avoids the magpylib interface and gives direct access to the field
        implementations. It is the fastet way to compute fields with magpylib.

    Shape (3,) inputs will automatically be tiled to shape (N,3) to fit with other
        inputs.

    Parameters
    ----------
    src_type: string
        Source type of computation. Must be either 'Box', 'Cylinder', ___

    pos: array_like, shape (3,) or (N,3), default=(0,0,0)
        Source positions in units of [mm].

    rot: scipy Rotation object, default=unit rotation
        Source rotations relative to the init_state.

    pos_obs: array_like, shape (3,) or (N,3)
        Observer positions in units of [mm]

    Homogeneous magnets Parameters
    ------------------------------
    mag: array_like, shape (3,)
        Homogeneous magnet magnetization vector (remanence field) in units of [mT].

    dim: array_like, shape is src_type dependent
        Magnet dimension input

    Specific Parameters:
    --------------------
    niter: int, default=config.ITER_CYLINDER=50
        Number of iterations for diametral magnetization computation using
        Simpsons approximation.

    Returns
    -------
    H-field: ndarray, shape (N,3)
        H-field generated by source at pos_obs in units of kA/m.
    """
    return getBHv_level2(bh=False, **kwargs)

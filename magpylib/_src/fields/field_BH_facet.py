"""
Implementations of analytical expressions for the magnetic field of a triangular facet.
Computation details in function docstrings.
"""
# pylance: disable=Code is unreachable
import numpy as np
from magpylib._src.input_checks import check_field_input


EPS = 1.0e-12


def cross2(a:np.ndarray, b:np.ndarray)->np.ndarray:
    """ pylance unreachable code workaround"""
    return np.cross(a, b)


def norm_vector(v)->np.ndarray:
    """
    Calculates normalized orthogonal vector on a plane defined by three vertices.
    """
    a = v[:, 1] - v[:, 0]
    b = v[:, 2] - v[:, 0]
    n = cross2(a, b)
    n_norm = np.linalg.norm(n, axis=-1)
    return n / np.expand_dims(n_norm, axis=-1)


def scalar3(R1, R2, R3)->np.ndarray:
    """
    Calculates (oriented) volume of the parallelepiped defined by the vectors R1, R2, R3
     = R1 * R2 x R3
    """
    return np.einsum("ij, ij->i", R1, cross2(R2, R3))


def solid_angle(R1, R2, R3, r1, r2, r3)->np.ndarray:
    """
    Calculates the solid angle of the triangle defined by the position vectors R1, R2, R3
    """
    N = scalar3(R1, R2, R3)
    D = (r1 * r2 * r3 +
        np.einsum("ij, ij->i", R1, R2) * r3 +
        np.einsum("ij, ij->i", R1, R3) * r2 +
        np.einsum("ij, ij->i", R2, R3) * r1)
    return 2.0 * np.arctan2(N, D)


# CORE
def magnet_facet_field(
    field: str,
    observers: np.ndarray,
    magnetization: np.ndarray,
    vertices: np.ndarray,
) -> np.ndarray:
    """Magnetic field generated by homogeneous triangular surface charges.

    Can be used to compute the field of a homogeneously magnetized body
    with triangular surface mesh. Each facet must be defined so that the
    normal vector points outwards.

    Parameters
    ----------
    field: str, default=`'B'`
        If `field='B'` return B-field in units of [mT], if `field='H'` return H-field
        in units of [kA/m].

    observers: ndarray, shape (n,3)
        Observer positions (x,y,z) in Cartesian coordinates in units of [mm].

    magnetization: ndarray, shape (n,3)
        Homogeneous magnetization vector in units of [mT]. The facet surface charge is the
        projection of the magnetization vector onto the surface normal vector. The order
        of the facet vertices defines the sign of the normal vector.

    vertices: ndarray, shape (n,3,3)
        Vertices of triangular faces of the format
        [(pos1a, pos1b, pos1c), (pos2a, pos2b, pos2c), ...].
        The vertex order defines the normal vector orientation of the face.

    Returns
    -------
    B-field or H-field: ndarray, shape (n,3)
        B/H-field of magnet in Cartesian coordinates (Bx, By, Bz) in units of [mT]/[kA/m].

    Notes
    -----
    Field computations implemented from Guptasarma, Geophysics, 1999, 64:1, 70-74
    """
    # pylint: disable=too-many-statements
    bh = check_field_input(field, "facet_field()")

    num_targets = len(observers)

    B = np.zeros((num_targets, 3))

    n = norm_vector(vertices)
    sigma = np.einsum("ij, ij->i", n, magnetization)
    R = []
    r = []
    for i in range(3):
        R.append(vertices[:, i] - observers)
        r.append(np.linalg.norm(R[i], axis=1))
    inout = np.fabs(n[:, 0] * R[i][:, 0] + n[:, 1] * R[i][:, 1] + n[:, 2] * R[i][:, 2])
    solid_angle_results = np.where(
        inout <= EPS, 0.0, solid_angle(R[2], R[1], R[0], r[2], r[1], r[0])
    )
    PP = np.zeros(num_targets)
    QQ = np.zeros(num_targets)
    RR = np.zeros(num_targets)
    for i in range(3):
        ii = (i+1)%3
        L = vertices[:, ii] - vertices[:, i]
        b = 2.0 * (R[i][:, 0] * L[:, 0] + R[i][:, 1] * L[:, 1] + R[i][:, 2] * L[:, 2])
        l = np.linalg.norm(L, axis=-1)
        bl = b / (2.0 * l)
        ind = np.fabs(r[i] + bl)
        I = np.where(
            ind > EPS,
            (1.0 / l)
            * np.log(
                (np.sqrt(l * l + b + r[i] * r[i]) + l + bl) / (np.fabs(r[i] + bl))
            ),
            -(1.0 / l) * np.log(np.fabs(l - r[i]) / r[i]),
        )
        PP += I * L[:, 0]
        QQ += I * L[:, 1]
        RR += I * L[:, 2]
    B[:, 0] += sigma * (n[:, 0] * solid_angle_results + n[:, 2] * QQ - n[:, 1] * RR)
    B[:, 1] += sigma * (n[:, 1] * solid_angle_results + n[:, 0] * RR - n[:, 2] * PP)
    B[:, 2] += sigma * (n[:, 2] * solid_angle_results + n[:, 1] * PP - n[:, 0] * QQ)

    B /= np.pi * 4

    # return B or compute and return H -------------
    if bh:
        return B

    H = B * 10 / 4 / np.pi  # mT -> kA/m
    return H


def magnet_facet_field_from_obj(
    field: str,
    observers: np.ndarray,
    magnetization: np.ndarray,
    vertices: np.ndarray,
    ) -> np.ndarray:
    """Helper function to compute the magnetic field of a Facet object
    Facet objects can have variable facet input shapes.
    This function tiles up all inputs, as well as observers and magnetization
    to yield proper input format for magnet_facet_field()
    """
    if vertices.ndim != 1:  # all vertices objects have same number of children
        n0, n1, *_ = vertices.shape
        vertices_tiled = vertices.reshape(-1, 3, 3)
        observers_tiled = np.repeat(observers, n1, axis=0)
        magnetization_tiled = np.repeat(magnetization, n1, axis=0)
        B = magnet_facet_field(
            field=field,
            observers=observers_tiled,
            magnetization=magnetization_tiled,
            vertices=vertices_tiled,
        )
        B = B.reshape((n0, n1, 3))
        B = np.sum(B, axis=1)
    else:
        nvs = [f.shape[0] for f in vertices]  # length of vertex set
        split_indices = np.cumsum(nvs)[:-1]  # remove last to avoid empty split
        vertices_tiled = np.concatenate([f.reshape((-1, 3, 3)) for f in vertices])
        observers_tiled = np.repeat(observers, nvs, axis=0)
        magnetization_tiled = np.repeat(magnetization, nvs, axis=0)
        B = magnet_facet_field(
            field="B",
            observers=observers_tiled,
            magnetization=magnetization_tiled,
            vertices=vertices_tiled,
        )
        b_split = np.split(B, split_indices)
        B = np.array([np.sum(bh, axis=0) for bh in b_split])

    return B

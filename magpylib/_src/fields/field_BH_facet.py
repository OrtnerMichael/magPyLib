"""
Implementations of analytical expressions for the magnetic field of a triangular facet.
Computation details in function docstrings.
"""
# pylance: disable=Code is unreachable
import numpy as np
from magpylib._src.input_checks import check_field_input


def vcross3(a:np.ndarray, b:np.ndarray)->np.ndarray:
    """
    vectorized cross product for 3d vectors. Is ~4x faster than np.cross when
    arrays are smallish. Only slightly faster for large arrays.
    input shape a,b: (n,3)
    returns: (n, 3)
    """
    result = np.array([
        a[:,1] * b[:,2] - a[:,2] * b[:,1], 
        a[:,2] * b[:,0] - a[:,0] * b[:,2], 
        a[:,0] * b[:,1] - a[:,1] * b[:,0]
    ])
    return result.T


def norm_vector(v)->np.ndarray:
    """
    Calculates normalized orthogonal vector on a plane defined by three vertices.
    """
    a = v[:, 1] - v[:, 0]
    b = v[:, 2] - v[:, 0]
    n = vcross3(a, b)
    n_norm = np.linalg.norm(n, axis=-1)
    return n / np.expand_dims(n_norm, axis=-1)


def solid_angle(R:np.ndarray, r:np.ndarray)->np.ndarray:
    """
    Vectorized computation of the solid angle of triangles.

    Triangle point indices are 1,2,3, different triangles are denoted by a,b,c,...
    The first triangle is defined as R1a, R2a, R3a.

    Input:
    R = [(R1a, R1b, R1c, ...), (R2a, R2b, R2c, ...), (R3a, R3b, R3c, ...)]
    r = [(|R1a|, |R1b|, |R1c|, ...), (|R2a|, |R2b|, |R2c|, ...), (|R3a|, |R3b|, |R3c|, ...)]

    Returns:
    [sangle_a, sangle_b, sangle_c, ...]
    """

    # Calculates (oriented) volume of the parallelepiped in vectorized form.
    N = np.einsum("ij, ij->i", R[2], vcross3(R[1], R[0]))

    D = (r[0] * r[1] * r[2] +
        np.einsum("ij, ij->i", R[2], R[1]) * r[0] +
        np.einsum("ij, ij->i", R[2], R[0]) * r[1] +
        np.einsum("ij, ij->i", R[1], R[0]) * r[2])
    return 2. * np.arctan2(N, D)


# CORE
def magnet_facet_field(
    field: str,
    observers: np.ndarray,
    magnetization: np.ndarray,
    vertices: np.ndarray,
) -> np.ndarray:
    """Magnetic field generated by homogeneous charges on triangular surfaces.

    Can be used to compute the field of a homogeneously magnetized body
    with triangular surface mesh. Each facet must be defined so that the
    normal vector points outwards.

    Parameters
    ----------
    field: str, default=`'B'`
        If `field='B'` return B-field in units of [mT], if `field='H'` return H-field
        in units of [kA/m].

    observers: ndarray, shape (n,3)
        Observer positions (x,y,z) in Cartesian coordinates in units of [mm].

    magnetization: ndarray, shape (n,3)
        Homogeneous magnetization vector in units of [mT]. The facet surface charge is the
        projection of the magnetization vector onto the surface normal vector. The order
        of the facet vertices defines the sign of the normal vector (right-hand-rule).

    vertices: ndarray, shape (n,3,3)
        Vertices of triangular faces of the format
        [(pos1a, pos1b, pos1c), (pos2a, pos2b, pos2c), ...].
        The vertex order defines the normal vector orientation of the face (right-hand-rule).

    Returns
    -------
    B-field or H-field: ndarray, shape (n,3)
        B/H-field of magnet in Cartesian coordinates (Bx, By, Bz) in units of [mT]/[kA/m].

    Examples
    --------

    Notes
    -----
    Field computations implemented from Guptasarma, Geophysics, 1999, 64:1, 70-74
    """
    # pylint: disable=too-many-statements
    bh = check_field_input(field, "facet_field()")

    n = norm_vector(vertices)
    sigma = np.einsum("ij, ij->i", n, magnetization) # vectorized inner product

    # rearrange, relative
    R = np.swapaxes(vertices, 0, 1) - observers
    r = np.linalg.norm(R, axis=2)

    # inout = np.einsum("ij, ij->i", n, R[2])
    # solid_angle_results = np.where(
    #     np.fabs(inout) <= EPS,
    #     0.0,
    #     solid_angle(R, r)
    # )

    L = vertices[:, (1,2,0)] - vertices[:, (0,1,2)]
    L = np.swapaxes(L, 0, 1)
    b = 2. * np.einsum("ijk, ijk->ij", R, L)
    l = np.linalg.norm(L, axis=-1)
    bl = b / (2. * l)
    ind = np.fabs(r + bl)
    I = np.where(
        ind>1.0e-12,
        1./l * np.log( (np.sqrt(l*l + b + r*r) + l + bl) / np.fabs(r+bl) ),
        -1./l * np.log(np.fabs(l-r) / r)
    )
    PQR = np.einsum("ij, ijk -> jk", I, L)
    B = sigma * ((n.T * solid_angle(R, r)) - vcross3(n, PQR).T)

    # return B or compute and return H -------------
    if bh:
        return B.T / np.pi / 4.

    H = B.T * 10. / 16. / np.pi**2  # mT -> kA/m
    return H


def magnet_facet_field_from_obj(
    field: str,
    observers: np.ndarray,
    magnetization: np.ndarray,
    vertices: np.ndarray,
    ) -> np.ndarray:
    """Helper function to compute the magnetic field of a Facet object
    Facet objects can have variable facet input shapes.
    This function tiles up all inputs, as well as observers and magnetization
    to yield proper input format for magnet_facet_field()
    """
    if vertices.ndim != 1:  # all vertices objects have same number of children
        n0, n1, *_ = vertices.shape
        vertices_tiled = vertices.reshape(-1, 3, 3)
        observers_tiled = np.repeat(observers, n1, axis=0)
        magnetization_tiled = np.repeat(magnetization, n1, axis=0)
        B = magnet_facet_field(
            field=field,
            observers=observers_tiled,
            magnetization=magnetization_tiled,
            vertices=vertices_tiled,
        )
        B = B.reshape((n0, n1, 3))
        B = np.sum(B, axis=1)
    else:
        nvs = [f.shape[0] for f in vertices]  # length of vertex set
        split_indices = np.cumsum(nvs)[:-1]  # remove last to avoid empty split
        vertices_tiled = np.concatenate([f.reshape((-1, 3, 3)) for f in vertices])
        observers_tiled = np.repeat(observers, nvs, axis=0)
        magnetization_tiled = np.repeat(magnetization, nvs, axis=0)
        B = magnet_facet_field(
            field="B",
            observers=observers_tiled,
            magnetization=magnetization_tiled,
            vertices=vertices_tiled,
        )
        b_split = np.split(B, split_indices)
        B = np.array([np.sum(bh, axis=0) for bh in b_split])

    return B

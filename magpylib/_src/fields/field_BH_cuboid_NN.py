"""
Implementations of analytical expressions for the magnetic field of homogeneously
magnetized Cuboids. Computation details in function docstrings.
"""

import numpy as np
from scipy.constants import mu_0 as MU0

from magpylib._src.input_checks import check_field_input

# pylint: disable=too-many-statements

import magpylib._src.fields.field_BH_cuboid

#####################
# load NN

import torch
import torch.nn as nn
from magpylib._src.fields.networks.networks import PINN_network
#from networks.networks import PINN_network

import os

# Get the path to the installed package
package_dir = os.path.dirname(magpylib.__file__)


# path_weights_B = '/home/stipsitzm/23_Hippie/hippie_magnetics/results_demag_one/B_global/model_multiplicative_field_correction_0_SiLU_MIN-1e-5.pth'
#path_weights_B = 'magpylib/_src/fields/networks/model_multiplicative_field_correction_0_SiLU_MIN-1e-5.pth'
path_weights_B = os.path.join(package_dir, "_src" ,"fields", "networks", "model_multiplicative_field_correction_0_SiLU_MIN-1e-5.pth")

# # networks for global fields (one network for whole space)
B_model = PINN_network(6, activation=nn.SiLU(), final_activation=nn.SiLU(),defined_with_dropout=True) # (a,b,Chi, x,y,z) -> (B_x, B_y, B_z)
B_model.load_state_dict(torch.load(path_weights_B, map_location=torch.device('cpu')))

#######################


def axis_string_to_int(s):
    if s == 'x':
        return 0
    elif s == 'y':
        return 1
    elif s == 'z':
        return 2
    else:
        raise Exception('Sorry, input needs to be "x", "y" or "z"')


def rotate(array, initial_axis, final_axis, abs):
    """
    returns adapted array after a coorinate transformation, where initial_axis is rotated to final_axis

    Args:
        array (ndarray, dim (n,3)): array where columns are exchanged according to rotation.
        initial_axis (string): axis that gets rotated from ('x', 'y', or 'z')
        final_axis (string): axis that gets rotated into ('x', 'y', or 'z')

    Returns:
        ndarray, dim (n,3): new array with exchanged axes

    """
    assert array.ndim == 2 and array.shape[1] == 3, 'wrong dimensions in input array'

    initial_axis = axis_string_to_int(initial_axis)
    final_axis = axis_string_to_int(final_axis)

    if initial_axis == final_axis:
        return array
    else:
        array_new = np.copy(array)
        array_new[:,final_axis] = array[:,initial_axis]
        if abs:
            array_new[:,initial_axis] = array[:,final_axis]
        else:
            array_new[:,initial_axis] = -array[:,final_axis]

    return array_new





def eval_NN(dimensions, observers, susceptibilities):

    dimensions_normalized = dimensions.T / dimensions[:,2]
    dimensions_normalized = dimensions_normalized.T
    dimensions_normalized[:,2] = susceptibilities
    dimension_batch = torch.tensor(dimensions_normalized, dtype=torch.float32)

    observers_normalized = np.abs(observers) / dimensions
    xyz_batch = torch.tensor(observers_normalized, dtype=torch.float32)

    res = B_model(dimension_batch, xyz_batch)

    return res


def magnet_cuboid_Bfield_NN(
    observers: np.ndarray,
    dimensions: np.ndarray,
    polarizations: np.ndarray,
    susceptibilities: np.ndarray,
):
    """B-field of homogeneously magnetized cuboids in Cartesian Coordinates.

    The cuboids sides are parallel to the coordinate axes. The geometric centers of the
    cuboids lie in the origin. The output is proportional to the polarization magnitude
    and independent of the length units chosen for observers and dimensions.

    Parameters
    ----------
    observers: ndarray, shape (n,3)
        Observer positions (x,y,z) in Cartesian coordinates.

    dimensions: ndarray, shape (n,3)
        Length of cuboids sides.

    polarizations: ndarray, shape (n,3)
        Magnetic polarization vectors.

    susceptibilities: ndarray, shape (n,)
        Magnetic susceptibilities

    Returns
    -------
    B-Field: ndarray, shape (n,3)
        B-field generated by Cuboids at observer positions.

    """

    polarizations_x = np.copy(polarizations)
    polarizations_x[:,1] = 0
    polarizations_x[:,2] = 0
    polarizations_y = np.copy(polarizations)
    polarizations_y[:,0] = 0
    polarizations_y[:,2] = 0
    polarizations_z = np.copy(polarizations)
    polarizations_z[:,0] = 0
    polarizations_z[:,1] = 0

    Bx = magpylib._src.fields.field_BH_cuboid.magnet_cuboid_Bfield(observers, dimensions, polarizations_x)
    By = magpylib._src.fields.field_BH_cuboid.magnet_cuboid_Bfield(observers, dimensions, polarizations_y)
    Bz = magpylib._src.fields.field_BH_cuboid.magnet_cuboid_Bfield(observers, dimensions, polarizations_z)



    # z-polarization
    res_z = eval_NN(dimensions, observers, susceptibilities)
    res_z = res_z.detach().numpy()

    # x-polarization
    dimensions_rotate_x = rotate(dimensions, 'x', 'z', True)
    observers_rotate_x = rotate(observers, 'x', 'z', True)

    res_x = eval_NN(dimensions_rotate_x, observers_rotate_x, susceptibilities)
    res_x = res_x.detach().numpy()
    res_x = rotate(res_x, 'z', 'x', True)

    # y-polarization
    dimensions_rotate_y = rotate(dimensions, 'y', 'z', True)
    observers_rotate_y = rotate(observers, 'y', 'z', True)

    res_y = eval_NN(dimensions_rotate_y, observers_rotate_y, susceptibilities)
    res_y = res_y.detach().numpy()
    res_y = rotate(res_y, 'z', 'y', True)

    result = Bx * res_x + By * res_y + Bz * res_z

    return result


def BHJM_magnet_cuboid_NN(
    field: str,
    observers: np.ndarray,
    dimension: np.ndarray,
    polarization: np.ndarray,
    susceptibilities: np.ndarray
) -> np.ndarray:
    """
    - translate cuboid core field to BHJM
    - treat special cases
    """

    RTOL_SURFACE = 1e-15  # relative distance tolerance to be considered on surface

    check_field_input(field)

    pol_x, pol_y, pol_z = polarization.T
    a, b, c = np.abs(dimension.T) / 2
    x, y, z = observers.T

    # allocate for output
    BHJM = polarization.astype(float)

    # SPECIAL CASE 1: polarization = (0,0,0)
    mask_pol_not_null = ~(
        (pol_x == 0) * (pol_y == 0) * (pol_z == 0)
    )  # 2x faster than np.all()

    # SPECIAL CASE 2: 0 in dimension
    mask_dim_not_null = (a * b * c).astype(bool)

    # SPECIAL CASE 3: observer lies on-edge/corner
    #   EPSILON to account for numerical imprecision when e.g. rotating
    #   /a /b /c to account for the missing scaling (EPSILON is large when
    #    a is e.g. EPSILON itself)

    # on-surface is not a special case
    mask_surf_x = abs(x_dist := abs(x) - a) < RTOL_SURFACE * a  # on surface
    mask_surf_y = abs(y_dist := abs(y) - b) < RTOL_SURFACE * b  # on surface
    mask_surf_z = abs(z_dist := abs(z) - c) < RTOL_SURFACE * c  # on surface

    # inside-outside
    mask_inside_x = x_dist < RTOL_SURFACE * a
    mask_inside_y = y_dist < RTOL_SURFACE * b
    mask_inside_z = z_dist < RTOL_SURFACE * c
    mask_inside = mask_inside_x & mask_inside_y & mask_inside_z

    # on edge (requires on-surface and inside-outside)
    mask_xedge = mask_surf_y & mask_surf_z & mask_inside_x
    mask_yedge = mask_surf_x & mask_surf_z & mask_inside_y
    mask_zedge = mask_surf_x & mask_surf_y & mask_inside_z
    mask_not_edge = ~(mask_xedge | mask_yedge | mask_zedge)

    mask_gen = mask_pol_not_null & mask_dim_not_null & mask_not_edge

    if field == "J":
        BHJM[~mask_inside] = 0
        return BHJM

    if field == "M":
        BHJM[~mask_inside] = 0
        return BHJM / MU0

    BHJM *= 0  # return (0,0,0) for all special cases
    BHJM[mask_gen] = magnet_cuboid_Bfield_NN(
        observers=observers[mask_gen],
        dimensions=dimension[mask_gen],
        polarizations=polarization[mask_gen],
        susceptibilities=susceptibilities[mask_gen],
    )
    if field == "B":
        return BHJM

    if field == "H":
        BHJM[mask_inside] -= polarization[mask_inside]
        return BHJM / MU0

    raise ValueError(  # pragma: no cover
        "`output_field_type` must be one of ('B', 'H', 'M', 'J'), " f"got {field!r}"
    )


if __name__ == "__main__":
    observers = np.array([[0,0,1], [1,2,3]])
    dimensions = np.array([[1,1,1], [1,2,3]])
    polarizations = np.array([[0,0,3], [1,1,1]])
    susceptibilities = np.array([1,1])

    res_NN = magnet_cuboid_Bfield_NN(observers, dimensions, polarizations, susceptibilities)
    res = magpylib._src.fields.field_BH_cuboid.magnet_cuboid_Bfield(observers, dimensions, polarizations)

    print('res NN', res_NN)
    print('res', res)

    print('res NN norm', np.linalg.norm(res_NN))
    print('res norm', np.linalg.norm(res))


    res_NN = BHJM_magnet_cuboid_NN('B', observers, dimensions, polarizations, susceptibilities)
    res = magpylib._src.fields.field_BH_cuboid.magnet_cuboid_Bfield(observers, dimensions, polarizations)
    print('res NN', res_NN)
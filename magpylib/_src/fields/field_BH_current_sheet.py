"""
Implementations of analytical expressions of current sheet
"""

# pylint: disable=too-many-positional-arguments

import numpy as np
from numpy.linalg import norm
from scipy.constants import mu_0 as MU0

from magpylib._src.input_checks import check_field_input


def assign_masks(observers, coordinates, current_densities, mask):
    if mask is None:
        x, y, z = observers.T
        u1, u2, v2 = coordinates.T
        ju, jv = current_densities.T
    else:
        x, y, z = observers[mask,:].T
        u1, u2, v2 = coordinates[mask,:].T
        ju, jv = current_densities[mask,:].T
    return (x, y, z, u1, u2, v2, ju, jv)

# CORE
def current_sheet_Hfield(
    observers: np.ndarray,
    coordinates: np.ndarray,
    current_densities: np.ndarray,
) -> np.ndarray:
    """H-field of current sheets.

    The elementar current sheet is defined as the triangle with the vertices (0,0,0), (u1,0,0), (u2,v2,0).
    The current flows in the direction of current_density. The field is set to (0,0,0) on the sheet itself. 
    The output is proportional to the current and independent of the length units chosen for observers and dimensions.

    Parameters
    ----------
    observers: ndarray, shape (n,3)
        Observer positions (x,y,z) in Cartesian coordinates.

    coordinates: ndarray, shape (n,3)
        Defining coordinates of elementar current sheet (0,0,0), (u1,0,0), (u2,v2,0), where 
        u1, u2, v2 = coordinates

    current_densities: ndarray, shape (n,2)
        x- and y-coordinates of electrical current densities in sheets. Since elementar current sheet lies in x-y-plane, no z-coordinate required.

    Returns
    -------
    H-Field: ndarray, shape (n,3)
        H-field generated by current sheets at observer positions.

    Notes
    -----
    Field computation via law of Biot Savart. See also countless online resources.
    eg. http://www.phys.uri.edu/gerhard/PHY204/tsl216.pdf
    """
    # rename
    x, y, z, u1, u2, v2, ju, jv = assign_masks(observers, coordinates, current_densities, None)

    # in-plane with triangle
    in_plane = np.abs(z) < 1e-15

    # critical value for condition, if observer within triangle or on the edges
    critical_value01 = (x*v2 + y*u2) / (u1 * v2)   #within triangle
    critical_value02 = y / v2   #within triangle
    critical_value1 = np.abs(y)    #edge1
    critical_value2 = np.abs(u2*y - v2*x)     #edge2
    critical_value3 = np.abs(v2*(x-u1) + y*(u1-u2))      #edge3


    # separate on-sheet cases (-> B=0)
    mask0 = in_plane & (-1e-15 <= critical_value01 + critical_value02) & (critical_value01 + critical_value02 <= 1+1e-15) & (critical_value01 >= 0) & (critical_value02 >= 0)    # each condition account for numerical issues

    # separate on-edge cases
    mask1 = in_plane & (critical_value1 < 1e-15) & ~mask0
    mask2 = in_plane & (critical_value2 < 1e-15) & ~mask0
    mask3 = in_plane & (critical_value3 < 1e-15) & ~mask0
    mask_plane = ~(mask0 | mask1 | mask2 | mask3) & in_plane
    mask_general = ~in_plane

    # calculate fields
    H = np.zeros_like(observers, dtype=float)

    x, y, z, u1, u2, v2, ju, jv = assign_masks(observers, coordinates, current_densities, mask_general)
    H[mask_general,0] = (np.arctan((-u2*(y**2 + z**2) + v2*x*y)/(v2*z*np.sqrt(x**2 + y**2 + z**2))) + np.arctan((v2*y*(u1 - x) - (u1 - u2)*(y**2 + z**2))/(v2*z*np.sqrt(u1**2 - 2*u1*x + x**2 + y**2 + z**2))) - np.arctan((-u2*(y**2 + z**2) - v2**2*x + v2*y*(u2 + x))/(v2*z*np.sqrt(u2**2 - 2*u2*x + v2**2 - 2*v2*y + x**2 + y**2 + z**2))) - np.arctan((-u1*(v2**2 - 2*v2*y + y**2 + z**2) + u2*(y**2 + z**2) + v2**2*x - v2*y*(u2 + x))/(v2*z*np.sqrt(u2**2 - 2*u2*x + v2**2 - 2*v2*y + x**2 + y**2 + z**2))))/(u1*v2*z)
    H[mask_general,2] = -(ju*np.arctanh(x/np.sqrt(x**2 + y**2 + z**2)) + ju*np.arctanh((u1 - x)/np.sqrt(u1**2 - 2*u1*x + x**2 + y**2 + z**2)) - (ju*(u1 - u2) - jv*v2)*np.arctanh((u1**2 - u1*(u2 + x) + u2*x + v2*y)/(np.sqrt(u1**2 - 2*u1*u2 + u2**2 + v2**2)*np.sqrt(u1**2 - 2*u1*x + x**2 + y**2 + z**2)))/np.sqrt(u1**2 - 2*u1*u2 + u2**2 + v2**2) + (ju*(u1 - u2) - jv*v2)*np.arctanh((u1*(u2 - x) - u2**2 + u2*x + v2*(-v2 + y))/(np.sqrt(u1**2 - 2*u1*u2 + u2**2 + v2**2)*np.sqrt(u2**2 - 2*u2*x + v2**2 - 2*v2*y + x**2 + y**2 + z**2)))/np.sqrt(u1**2 - 2*u1*u2 + u2**2 + v2**2) + (ju*u2 + jv*v2)*np.arctanh((-u2*x - v2*y)/(np.sqrt(u2**2 + v2**2)*np.sqrt(x**2 + y**2 + z**2)))/np.sqrt(u2**2 + v2**2) - (ju*u2 + jv*v2)*np.arctanh((u2**2 - u2*x + v2*(v2 - y))/(np.sqrt(u2**2 + v2**2)*np.sqrt(u2**2 - 2*u2*x + v2**2 - 2*v2*y + x**2 + y**2 + z**2)))/np.sqrt(u2**2 + v2**2))/(u1*v2)
    

    x, y, z, u1, u2, v2, ju, jv = assign_masks(observers, coordinates, current_densities, mask_plane)
    H[mask_plane,2] = (ju*np.arctanh(x/np.sqrt(x**2 + y**2)) + ju*np.arctanh((u1 - x)/np.sqrt(u1**2 - 2*u1*x + x**2 + y**2)) - (ju*(u1 - u2) - jv*v2)*np.arctanh((u1**2 - u1*(u2 + x) + u2*x + v2*y)/(np.sqrt(u1**2 - 2*u1*u2 + u2**2 + v2**2)*np.sqrt(u1**2 - 2*u1*x + x**2 + y**2)))/np.sqrt(u1**2 - 2*u1*u2 + u2**2 + v2**2) + (ju*(u1 - u2) - jv*v2)*np.arctanh((u1*(u2 - x) - u2**2 
        + u2*x + v2*(-v2 + y))/(np.sqrt(u1**2 - 2*u1*u2 + u2**2 + v2**2)*np.sqrt(u2**2 - 2*u2*x + v2**2 - 2*v2*y + x**2 + y**2)))/np.sqrt(u1**2 - 2*u1*u2 + u2**2 + v2**2) + (ju*u2 + jv*v2)*np.arctanh((-u2*x - v2*y)/(np.sqrt(u2**2 + v2**2)*np.sqrt(x**2 + y**2)))/np.sqrt(u2**2 + v2**2) - (ju*u2 + jv*v2)*np.arctanh((u2**2 - u2*x + v2*(v2 - y))/(np.sqrt(u2**2 + v2**2)*np.sqrt(u2**2 - 2*u2*x + v2**2 - 2*v2*y + x**2 + y**2)))/np.sqrt(u2**2 + v2**2))/(u1*v2)
    
    x, y, z, u1, u2, v2, ju, jv = assign_masks(observers, coordinates, current_densities, mask1)
    H[mask1,2] = (-ju*x*np.log(np.abs(x))/np.sqrt(x**2) - ju*(u1 - x)*np.log(np.abs(-u1 + x))/np.sqrt((u1 - x)**2) + (ju*(u1 - u2) - jv*v2)*np.arctanh((u1*(-u2 + x) + u2**2 - u2*x + 
        v2**2)/(np.sqrt(u1**2 - 2*u1*u2 + u2**2 + v2**2)*np.sqrt(u2**2 - 2*u2*x + v2**2 + x**2)))/np.sqrt(u1**2 - 2*u1*u2 + u2**2 + v2**2) + (ju*(u1 
        - u2) - jv*v2)*np.arctanh((u1 - u2)*(u1 - x)/(np.sqrt(u1**2 - 2*u1*u2 + u2**2 + v2**2)*np.sqrt((u1 - x)**2)))/np.sqrt(u1**2 - 2*u1*u2 + u2**2 + v2**2) + (ju*u2 + jv*v2)*np.arctanh((u2**2 - u2*x + v2**2)/(np.sqrt(u2**2 + v2**2)*np.sqrt(u2**2 - 2*u2*x + v2**2 + x**2)))/np.sqrt(u2**2 + v2**2) - (ju*u2 + jv*v2)*np.arctanh(u2*(u1 - x)/(np.sqrt(u2**2 + v2**2)*np.sqrt((u1 - x)**2)))/np.sqrt(u2**2 + v2**2))/(u1*v2)
    
    x, y, z, u1, u2, v2, ju, jv = assign_masks(observers, coordinates, current_densities, mask2)
    H[mask2,2] = (-ju*np.arctanh((u1*v2 - u2*y)/(v2*np.sqrt(u1**2 - 2*u1*u2*y/v2 + y**2*(u2**2/v2**2 + 1)))) + ju*np.arctanh(u2*(v2 - y)/(v2*np.sqrt((u2**2 + v2**2)*(v2 - y)**2/v2**2))) + (ju*(u1 - u2) - jv*v2)*np.arctanh((u1**2*v2 - u1*u2*(v2 + y) + y*(u2**2 + v2**2))/(v2*np.sqrt(u1**2 - 2*u1*u2*y/v2 + y**2*(u2**2/v2**2 + 1))*np.sqrt(u1**2 - 2*u1*u2 + u2**2 + v2**2)))/np.sqrt(u1**2 - 2*u1*u2 + u2**2 + v2**2) + (ju*(u1 - u2) - jv*v2)*np.arctanh((v2 - y)*(-u1*u2 + u2**2 + v2**2)/(v2*np.sqrt((u2**2 + v2**2)*(v2 - y)**2/v2**2)*np.sqrt(u1**2 - 2*u1*u2 + u2**2 + v2**2)))/np.sqrt(u1**2 - 2*u1*u2 + u2**2 + v2**2) + y*(ju*u2 + jv*v2)*np.log(np.abs(y*(-u2**2 - v2**2)))/(v2*np.sqrt(y**2*(u2**2 + v2**2)/v2**2)) + (v2 - y)*(ju*u2 + jv*v2)*np.log(np.abs((u2**2 + v2**2)*(v2 - y)))/(v2*np.sqrt((u2**2 + v2**2)*(v2 - y)**2/v2**2)))/(u1*v2)
    
    x, y, z, u1, u2, v2, ju, jv = assign_masks(observers, coordinates, current_densities, mask3)
    H[mask3,2] = (ju*v2*np.arctanh((u1*(-v2 + y) - u2*y)/(v2*np.sqrt((u1**2*(v2 - y)**2 + 2*u1*u2*y*(v2 - y) + y**2*(u2**2 + v2**2))/v2**2))) + ju*v2*np.arctanh((u1 - u2)*(v2 - y)/(v2*np.sqrt((v2 - y)**2*(u1**2 - 2*u1*u2 + u2**2 + v2**2)/v2**2))) - v2*(ju*u2 + jv*v2)*np.arctanh((u1*u2*(-v2 + y) + y*(-u2**2 - v2**2))/(v2*np.sqrt((u1**2*(v2 - y)**2 + 2*u1*u2*y*(v2 - y) + y**2*(u2**2 + v2**2))/v2**2)*np.sqrt(u2**2 + v2**2)))/np.sqrt(u2**2 + v2**2) + v2*(ju*u2 + jv*v2)*np.arctanh((v2 - y)*(-u1*u2 + u2**2 + v2**2)/(v2*np.sqrt((v2 - y)**2*(u1**2 - 2*u1*u2 + u2**2 + v2**2)/v2**2)*np.sqrt(u2**2 + v2**2)))/np.sqrt(u2**2 + v2**2) - y*(ju*(-u1 + u2) + jv*v2)*np.log(np.abs(y*(-u1**2 + 2*u1*u2 - u2**2 - v2**2)))/np.sqrt(y**2*(u1**2 - 2*u1*u2 + u2**2 + v2**2)/v2**2) - (v2 - y)*(ju*(-u1 + u2) + jv*v2)*np.log(np.abs((v2 - y)*(u1**2 - 2*u1*u2 + u2**2 + v2**2)))/np.sqrt((v2 - y)**2*(u1**2 - 2*u1*u2 + u2**2 + v2**2)/v2**2))/(u1*v2**2)


    H[:,1] = H[:,0]     #copy?

    x, y, z, u1, u2, v2, ju, jv = assign_masks(observers, coordinates, current_densities, None)
    H[:,0] *= jv*z*u1*v2 / (4*np.pi)
    H[:,1] *= -ju*z*u1*v2 / (4*np.pi)
    H[:,2] *= u1*v2 / (4*np.pi)

    return H


def BHJM_current_sheet(
    field: str,
    observers: np.ndarray,
    coordinates: np.ndarray,
    current_densities: np.ndarray,
) -> np.ndarray:
    """
    - translate Polyline field to BHJM
    - treat some special cases
    """
    # pylint: disable=too-many-statements

    check_field_input(field)

    BHJM = np.zeros_like(observers, dtype=float)

    if field in "MJ":
        return BHJM
    
    # just renaming
    u1, u2, v2 = coordinates.T

    # Check for zero-length segments (or discontinuous)
    mask_nan_u1 = np.isnan(u1)
    mask_nan_u2 = np.isnan(u2)
    mask_nan_v2 = np.isnan(v2)
    mask_degenerated = (np.abs(u1) < 1e-15) |  (np.abs(v2) < 1e-15)
    mask0 = mask_nan_u1 | mask_nan_u2 | mask_nan_v2 | mask_degenerated
    not_mask0 = ~mask0  # avoid multiple computation of ~mask

    if np.all(mask0):
        return BHJM

    # continue only with non-zero segments
    if np.any(mask0):
        observers = observers[not_mask0]
        coordinates = coordinates[not_mask0]
        current_densities = current_densities[not_mask0]

    BHJM[not_mask0] = current_sheet_Hfield(
        observers=observers,
        coordinates = coordinates,
        current_densities=current_densities,
    )

    if field == "H":
        return BHJM

    if field == "B":
        return BHJM * MU0

    raise ValueError(  # pragma: no cover
        "`output_field_type` must be one of ('B', 'H', 'M', 'J'), " f"got {field!r}"
    )
